(* --------------------------------------------------------------------
 * Copyright (c) - 2012--2016 - IMDEA Software Institute
 * Copyright (c) - 2012--2018 - Inria
 * Copyright (c) - 2012--2018 - Ecole Polytechnique
 *
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

require import AllCore Distr FSet.

pragma +implicits. pragma -oldip.

(** A PRF is a family of functions F from domain D to finite range R
    indexed by a keyspace K equipped with a (lossless) distribution dK. *)
type D, R, K.

op dK: { K distr | is_lossless dK } as dK_ll.

module type PRF = {
  proc keygen(): K
  proc f(_: K * D): R
}.

module type PRF_Wrapped = {
  proc init(): unit
  proc f(_ : D): R
}.

module type PRF_Oracles = {
  proc f(_: D): R
}.

module type Distinguisher (F : PRF_Oracles) = {
  proc distinguish(): bool
}.

module IND (F : PRF_Wrapped) (D : Distinguisher) = {
  proc main(): bool = {
    var b;

         F.init();
    b <@ D(F).distinguish();
    return b;
  }
}.

(* -------------------------------------------------------------------- *)
abstract theory RF.
require import SmtMap.

op dR: { R distr | is_lossless dR } as dR_ll.

module RF = {
  var m : (D,R) fmap

  proc init(): unit = {
    m  <- empty;
  }

  proc f(x:D): R = {
    if (x \notin m) {
      m.[x]  <$ dR;
    }
    return (oget m.[x]);
  }
}.
end RF.

(* -------------------------------------------------------------------- *)
abstract theory PRF.

op F : K -> D -> R.

module PRF : PRF = {
  proc keygen(): K = {
    var k;

    k <$ dK;
    return k;
  }

  proc f(k:K, x:D) : R = { return F k x; }
}.

module PRF_Wrapped = {
  var k : K

  proc init() = { k <$ dK; }
  proc f(x: D) = { return F k x; }
}.
end PRF.
