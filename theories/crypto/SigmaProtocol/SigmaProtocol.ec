(* --------------------------------------------------------------------
 * Copyright (c) - 2016--2017 - Roberto Metere (r.metere2@ncl.ac.uk)
 *
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

(* A formalisation of generic Sigma protocols *)
require import AllCore Distr DProd.

abstract theory SP.
  type statement. (* x in Lindell *)   
  type witness.   (* w in Lindell *)
  type message.   (* a in Lindell, initial message from the prover *)
  type challenge. (* e in Lindell, challenge  randomly generated by the verifier *)
  type response.  (* z in Lindell, proof generate by the prover *)

  (* The relation between x and w *)
  op R (x: statement) (w: witness): bool.

  (* Randomly generate a challenge *) 
  op challenges : challenge distr. 
  
  op verify : statement -> message -> challenge -> response ->  bool.

  module type Prover = {
    proc * init (x:statement, w: witness) : message 
    proc respond (e: challenge) : response 
  }.

  module Completeness (P:Prover) = {
    proc main (x:statement, w:witness) = {
      var a, e, z;
      a <@ P.init(x, w);
      e <$ challenges;
      z <@ P.respond(e);
      return verify x a e z;
    } 
  }.

  (* op Completeness P = 
      \forall &m x w, R x w => Pr[Completeness(P).main (x,w)@ &m : res] = 1%r
    or equivalently 
     phoare [Completeness(P).main : R x w ==> res] = 1%r.

  *)
   
  module type KnowledgeExtractor = {
    proc * extract(x: statement, a: message, e: challenge, z: response, e': challenge, z': response) :
      witness
  }.

  module SpecialSoundness (KE: KnowledgeExtractor) = {
    proc main(x: statement, a: message, e: challenge, z: response, e': challenge, z': response) = {
      var w;
      w <@ KE.extract(x, a, e, z, e', z');
      return R x w;
    } 
  }.

  (* op SpecialSoundness (KE:KnowledgeExtractor) = 
     phoare [SpecialSoundness(KE).main : verify x a e z /\ verify x a e' z' /\ e <> e' ==> res] =  1%r.
  *)

  module type Simulator = { 
    proc * simulate(x: statement, e: challenge) : message * response
  }.

  module RealP (P:Prover) = { 
    proc main (x:statement, w:witness, e:challenge) = {
      var a, z;
      a <@ P.init (x, w);
      z <@ P.respond(e);
      return (a, z);
    } 
  }.

  (* Special honest verifier zero knowledge
     op sHVZK (S:Simulator) (P:Prover) = 
       forall x w e a z &m,  R x w =>  
         Pr[ RealP(P).main(x, w, e) @ &m : res = (a, z)] = 
         Pr[ M.simulate(x,e) @ &m : res = (a, z)].
     or equivalently 
        equiv [RealP(P).main ~ S.simulate : (R x w) {1} /\ ={x,e} ==> ={res}]
   *)

  module RealP' (P:Prover) = { 
    proc main (x:statement, w:witness) = {
      var a, e, z;
      e <$ challenges;
      (a, z) <@ RealP(P).main(x, w, e);
      return (a, e, z);
    } 
  }.

  module type Simulator' = {
    proc * simulate(x: statement) : message * challenge * response 
  }.

  module S'(S:Simulator) : Simulator' = {
    proc simulate(x:statement) = {
      var a, e, z;
      e <$ challenges;
      (a, z) <@ S.simulate(x, e);
      return (a, e, z);
    }
  }.

  lemma sHVZK_HVZK (P<:Prover) (S<:Simulator{P}) :
    equiv [RealP(P).main ~ S.simulate : (R x w) {1} /\ ={x,e} ==> ={res}] =>
    equiv [RealP'(P).main ~ S'(S).simulate : (R x w) {1} /\ ={x} ==> ={res}].
  proof.
    by move=> h; proc; seq 1 1 : (#pre /\ ={e}); [ auto | call h].
  qed.

end SP.

abstract theory AndComp.
  type challenge.
  op challenges : challenge distr.

  clone SP as SP1 with
    type challenge <- challenge,
    op challenges <- challenges.
  clone SP as SP2 with 
    type challenge <- challenge,
    op challenges <- challenges.

  type statement = SP1.statement * SP2.statement.
  type witness = SP1.witness * SP2.witness.
  type message = SP1.message * SP2.message.
  type response = SP1.response * SP2.response.

  op R (x:statement) (w:witness) = SP1.R x.`1 w.`1 /\ SP2.R x.`2 w.`2.

  op verify (x:statement) (a:message) e (z:response) = 
    SP1.verify x.`1 a.`1 e z.`1 /\ SP2.verify x.`2 a.`2 e z.`2.

  clone include SP with 
    type statement <- statement, 
    type witness <- witness, 
    type message <- message, 
    type challenge <- challenge, 
    type response <- response, 
    op R <- R, 
    op challenges <- challenges, 
    op verify <- verify.

  module P (P1:SP1.Prover) (P2:SP2.Prover) : Prover = { 
    proc init (x:statement, w: witness) : message = {
      var a1, a2; 
      a1 <@ P1.init(x.`1, w.`1);
      a2 <@ P2.init(x.`2, w.`2);
      return (a1, a2);
    }

    proc respond (e: challenge) : response = {
      var z1, z2; 
      z1 <@ P1.respond(e);
      z2 <@ P2.respond(e);
      return (z1, z2);
    }
  }.

  module KE(KE1:SP1.KnowledgeExtractor, KE2:SP2.KnowledgeExtractor) : KnowledgeExtractor = {
    proc extract(x: statement, a: message, e: challenge, z: response, e': challenge, z': response) = {
      var w1, w2;
      w1 <@ KE1.extract(x.`1, a.`1, e, z.`1, e', z'.`1);
      w2 <@ KE2.extract(x.`2, a.`2, e, z.`2, e', z'.`2);
      return (w1, w2);
    }
  }.

  module S(S1:SP1.Simulator, S2:SP2.Simulator) : Simulator = {
    proc simulate(x: statement, e: challenge) = { 
      var a1, z1, a2, z2;
      (a1, z1) <@ S1.simulate(x.`1, e);
      (a2, z2) <@ S2.simulate(x.`2, e);
      return ((a1,a2),(z1,z2));
    } 
  }.
    
  section COMPLETENESS.

  declare module P1 : SP1.Prover.
  declare module P2 : SP2.Prover {P1}.
  axiom dc_ll : is_lossless challenges.
  axiom init1_ll : islossless P1.init.
  axiom resp1_ll : islossless P1.respond.
  axiom init2_ll : islossless P2.init.
  axiom resp2_ll : islossless P2.respond.

  local module AUX1= {
    proc main(x:statement, w: witness) = {
      var a1, a2, z1, z2, e; 

      a1 <@ P1.init(x.`1, w.`1);
      a2 <@ P2.init(x.`2, w.`2);
      e <$ challenges;
      z1 <@ P1.respond(e);
      z2 <@ P2.respond(e);
      return (SP1.verify x.`1 a1 e z1, SP2.verify x.`2 a2 e z2);
    }
  }.

  hint solve 0 random : dc_ll.
  local lemma AUX1_ll : islossless AUX1.main.
  proof.
    islossless.
    + by apply resp2_ll. + by apply resp1_ll. 
    + by apply init2_ll. + by apply init1_ll.
  qed.

  lemma Completeness : 
    phoare [SP1.Completeness(P1).main : SP1.R x w ==> res] = 1%r => 
    phoare [SP2.Completeness(P2).main : SP2.R x w ==> res] = 1%r => 
    phoare [Completeness(P(P1,P2)).main : R x w ==> res] = 1%r.  
  proof.
    move=> h1 h2; bypr => &m hR.
    have -> : Pr[Completeness(P(P1, P2)).main(x{m}, w{m}) @ &m : res] = 
              Pr[AUX1.main(x{m},w{m}) @ &m : res.`1 /\ res.`2]; last first.
    + byphoare (_: R x w ==> res.`1 /\ res.`2) => // {&m hR}.
      phoare split ! (1%r) (0%r) => //; 1: by conseq AUX1_ll.
      conseq (: !res.`1 \/ !res.`2); 1: by move=> *;rewrite negb_and.
      have h : phoare [AUX1.main : R x w ==> !res.`1] = 0%r.
      + phoare split ! (1%r) (1%r) => //;1: by conseq AUX1_ll.
        bypr => &m hR.
        have ->// : Pr[AUX1.main(x{m}, w{m}) @ &m : res.`1] = 
                    Pr[SP1.Completeness(P1).main(x{m}.`1, w{m}.`1) @ &m : res].
        + byequiv => //; proc.
          by call{1} resp2_ll; call (:true); rnd; call{1} init2_ll; call(:true).
        by byphoare h1 => // /#.
      phoare split 0%r 0%r => //. 
      + phoare split ! (1%r) (1%r) => //;1: by conseq AUX1_ll.
        bypr => &m hR.
        have ->// : Pr[AUX1.main(x{m}, w{m}) @ &m : res.`2] = 
                    Pr[SP2.Completeness(P2).main(x{m}.`2, w{m}.`2) @ &m : res].
        + byequiv => //; proc.
          by call (:true); call{1} resp1_ll; rnd; call(:true); call{1} init1_ll.
        by byphoare h2 => // /#.
      by conseq (: _ ==> !res.`1 : <= 0%r) => //; conseq h.
    by byequiv => //; proc; inline *; wp; do 2! call (:true); auto; do 2!call (:true); auto => />.
  qed.

  end section COMPLETENESS.

  section SPECIAL_SOUNDNESS.

  declare module KE1: SP1.KnowledgeExtractor.
  declare module KE2: SP2.KnowledgeExtractor {KE1}.

  local module AUX2 = {
    proc main(x: statement, a: message, e: challenge, z: response, e': challenge, z': response) = {
      var b1, b2;
      b1 <@ SP1.SpecialSoundness(KE1).main(x.`1, a.`1, e, z.`1, e', z'.`1);
      b2 <@ SP2.SpecialSoundness(KE2).main(x.`2, a.`2, e, z.`2, e', z'.`2);
      return (b1, b2);
    }
  }.

  lemma SpecialSoundness :
    phoare [SP1.SpecialSoundness(KE1).main: 
      SP1.verify x a e z /\ SP1.verify x a e' z' /\ e <> e' ==> res]= 1%r =>
    phoare [SP2.SpecialSoundness(KE2).main: 
      SP2.verify x a e z /\ SP2.verify x a e' z' /\ e <> e' ==> res]= 1%r =>
    phoare [SpecialSoundness(KE(KE1,KE2)).main: 
      verify x a e z /\ verify x a e' z' /\ e <> e' ==> res]= 1%r.
  proof.
    move=> h1 h2; bypr => &m hR.
    have -> : 
     Pr[SpecialSoundness(KE(KE1, KE2)).main(x{m},a{m},e{m},z{m},e'{m},z'{m}) @ &m : res] =   
     Pr[AUX2.main(x{m},a{m},e{m},z{m},e'{m},z'{m}) @ &m : res.`1 /\ res.`2].
    byequiv (_: ={arg, glob KE1, glob KE2} ==> res{1} = (res.`1 /\ res.`2){2}) => //.
    + proc; inline *; do 2! (wp; call(:true)); auto.
    byphoare (_:verify x a e z /\ verify x a e' z' /\ e <> e' ==> res.`1 /\ res.`2) => //.
    proc; call h2; call h1; auto => />.
  qed.

  end section SPECIAL_SOUNDNESS.

  section SHVZK.
    declare module P1: SP1.Prover.
    declare module P2: SP2.Prover {P1}.

    declare module S1 : SP1.Simulator.
    declare module S2 : SP2.Simulator.

    lemma sHVZK : 
      equiv [SP1.RealP(P1).main ~ S1.simulate : (SP1.R x w) {1} /\ ={x,e} ==> ={res}] =>
      equiv [SP2.RealP(P2).main ~ S2.simulate : (SP2.R x w) {1} /\ ={x,e} ==> ={res}] =>
      equiv [RealP(P(P1,P2)).main ~ S(S1,S2).simulate : (R x w) {1} /\ ={x,e} ==> ={res}].
    proof.
      move=> h1 h2; proc; inline *; swap{1} 5 3; wp.
      transitivity*{1} { (a1,z1) <@ SP1.RealP(P1).main(x.`1, w.`1, e);
                         (a2,z2) <@ SP2.RealP(P2).main(x.`2, w.`2, e); } => //; 1: smt().
      + by inline *; swap{2} [5..6] 4; do 4! (wp; call (:true)); auto.
      by call h2; call h1; auto => />.
    qed.

  end section SHVZK.

end AndComp.

(* TODO: Move this *)
type ('a, 'b) sum = [
  | Left of 'a
  | Right of 'b
  ].

op is_left ['a 'b] (s:('a,'b) sum) = 
   with s = Left _  => true 
   with s = Right _ => false.

op lget ['a 'b] (s:('a,'b) sum) = 
   with s = Left a  => a
   with s = Right _  => witness.

op rget ['a 'b] (s:('a,'b) sum) = 
   with s = Left  _   => witness
   with s = Right b  => b.

lemma lget_l ['a 'b] (a:'a) : lget <:'a, 'b> (Left a) = a.
proof. done. qed.

lemma rget_r ['a 'b] (b:'b) : rget <:'a, 'b> (Right b) = b.
proof. done. qed.

hint simplify lget_l, rget_r.

abstract theory OrComp.

  type challenge.
  op challenges : challenge distr.
  axiom challenges_ll : is_lossless challenges.
  axiom challenges_funi : is_funiform challenges.

  hint solve 0 random : challenges_ll challenges_funi.

  (* TODO: have a generic structure for this *)
  op (+) : challenge -> challenge -> challenge.
  axiom add_cancel (x y:challenge) : x + y + y = x.
  axiom addC (x y: challenge) : x + y = y + x.

  clone SP as SP1 with
    type challenge <- challenge,
    op challenges <- challenges.
 
  clone SP as SP2 with 
    type challenge <- challenge,
    op challenges <- challenges.

  (* Here we assume that the relation are "full" ie for all x, there exists a w such that R x w.
     Else special soundness is not provable *)

  axiom R1_full x : exists w, SP1.R x w.
  axiom R2_full x : exists w, SP2.R x w.
 
  type statement = SP1.statement * SP2.statement.
  type witness = (SP1.witness, SP2.witness) sum.
  type message = SP1.message * SP2.message.
  type response = (SP1.response * challenge) * (SP2.response * challenge).

  op R (x:statement) (w:witness) = 
    with w = Left w1 => SP1.R x.`1 w1 
    with w = Right w2 => SP2.R x.`2 w2.
 
  op verify (x:statement) (a:message) e (z:response) = 
    let (z1,e1) = z.`1 in
    let (z2,e2) = z.`2 in
    e = e1 + e2 /\ 
    SP1.verify x.`1 a.`1 e1 z1 /\
    SP2.verify x.`2 a.`2 e2 z2.
    
  clone include SP with 
    type statement <- statement, 
    type witness <- witness, 
    type message <- message, 
    type challenge <- challenge, 
    type response <- response,
    op R <- R,
    op challenges <- challenges, 
    op verify <- verify.

  module P (P1:SP1.Prover) (S1:SP1.Simulator) (P2:SP2.Prover) (S2:SP2.Simulator) : Prover = { 
    var e1: challenge
    var e2: challenge
    var z1: SP1.response
    var z2: SP2.response
    var a1: SP1.message
    var a2: SP2.message
    var w_ : witness

    proc init (x:statement, w: witness) : message = {
      var w1, w2; 
      w_ <- w;
      if (is_left w) {
        w1 <- lget w;
        a1 <@ P1.init(x.`1, w1);
        e2 <$ challenges;
        (a2,z2) <- S2.simulate(x.`2, e2);
      } else {
        w2 <- rget w;
        a2 <@ P2.init(x.`2, w2);
        e1 <$ challenges;
        (a1,z1) <- S1.simulate(x.`1, e1);
      } 
      return (a1, a2);
    }

    proc respond (e:challenge) = {
      if (is_left w_) {
        e1 <- e + e2;
        z1 <@ P1.respond(e1);
      } else {
        e2 <- e + e1;
        z2 <@ P2.respond(e2);
      }
      return ((z1,e1),(z2,e2));
    }
  }.

  module KE(KE1:SP1.KnowledgeExtractor, KE2:SP2.KnowledgeExtractor) : KnowledgeExtractor = {
    proc extract(x: statement, a: message, e: challenge, z: response, e': challenge, z': response) = {
      var w, w1, w2;
      if (z.`1.`2 <> z'.`1.`2) {
        w1 <@ KE1.extract(x.`1, a.`1, z.`1.`2, z.`1.`1, z'.`1.`2, z'.`1.`1);
        w <- Left w1;
      } else {
        w2 <@ KE2.extract(x.`2, a.`2, z.`2.`2, z.`2.`1, z'.`2.`2, z'.`2.`1);
        w <- Right w2;
      }
      return w;
    }
  }.

  module S(S1:SP1.Simulator, S2:SP2.Simulator) = {
    proc simulate(x: statement, e: challenge) = { 
      var a1, z1, a2, z2, e1, e2;
      e2 <$ challenges;
      e1 <- e + e2;
      (a1, z1) <@ S1.simulate(x.`1, e1);
      (a2, z2) <@ S2.simulate(x.`2, e2);
      return ((a1,a2),((z1,e1),(z2,e2)));
    } 
  }.

  section COMPLETENESS.

  declare module P1 : SP1.Prover {P}.
  declare module S1 : SP1.Simulator {P}.
  declare module P2 : SP2.Prover {P, P1, S1}.
  declare module S2 : SP2.Simulator {P, P1}.

  local module AUX1_L = {
    proc main(x:statement, w1: SP1.witness, w2:SP2.witness) = {
      var a1,a2,z1,z2,b1,b2,e1,e2;
      e1 <$ challenges;
      (a1,z1) <@ SP1.RealP(P1).main(x.`1, w1, e1);
      b1 <- SP1.verify x.`1 a1 e1 z1;
      e2 <$ challenges;
      (a2,z2) <@ S2.simulate(x.`2, e2); 
      b2 <- SP2.verify x.`2 a2 e2 z2;
      return b1 /\ b2;
    }
  }.
  
  local module AUX1_R = {
    proc main(x:statement, w1: SP1.witness, w2:SP2.witness) = {
      var a1,a2,z1,z2,b1,b2,e1,e2;
      e1 <$ challenges;
      (a1,z1) <@ S1.simulate(x.`1, e1);
      b1 <- SP1.verify x.`1 a1 e1 z1;
      e2 <$ challenges;
      (a2,z2) <@ SP2.RealP(P2).main(x.`2, w2, e2); 
      b2 <- SP2.verify x.`2 a2 e2 z2;
      return b1 /\ b2;
    }
  }.

  local module AUX2 = {
    proc main(x:statement, w1: SP1.witness, w2:SP2.witness) = {
      var a1,a2,z1,z2,b1,b2,e1,e2;
      e1 <$ challenges;
      (a1,z1) <@ SP1.RealP(P1).main(x.`1, w1, e1);
      b1 <- SP1.verify x.`1 a1 e1 z1;
      e2 <$ challenges;
      (a2,z2) <@ SP2.RealP(P2).main(x.`2, w2, e2); 
      b2 <- SP2.verify x.`2 a2 e2 z2;
      return b1 /\ b2;
    }
  }.

  local module AUX3 = {
     proc main(x:statement, w1: SP1.witness, w2:SP2.witness) = {
       var b1, b2;
       b1 <@ SP1.Completeness(P1).main(x.`1, w1);
       b2 <@ SP2.Completeness(P2).main(x.`2, w2);
       return b1 /\ b2;
     }
   }.

  local lemma prAUX2 &m (x_: statement) w1_ w2_ :
    phoare [SP1.Completeness(P1).main : SP1.R x w ==> res] = 1%r => 
    phoare [SP2.Completeness(P2).main : SP2.R x w ==> res] = 1%r => 
    SP1.R x_.`1 w1_ => SP2.R x_.`2 w2_ => 
    Pr[AUX2.main(x_, w1_, w2_) @ &m : res] = 1%r.
  proof.
    move=> hc1 hc2 hR1 hR2.  
    have -> : Pr[AUX2.main(x_, w1_, w2_) @ &m : res] =
              Pr[AUX3.main(x_, w1_, w2_) @ &m : res].
    + byequiv => //; proc; inline *. 
      swap{1} 9 -7; swap{2} 4 -3; swap{2} 10 -8.
      by do !(auto; call (:true)); auto.
    byphoare (: SP1.R x.`1 w1 /\ SP2.R x.`2 w2 ==> res) => //.
    by proc; call hc2; call hc1; auto.
  qed.

  lemma Completeness : 
    phoare [SP1.Completeness(P1).main : SP1.R x w ==> res] = 1%r => 
    phoare [SP2.Completeness(P2).main : SP2.R x w ==> res] = 1%r => 
    equiv [SP1.RealP(P1).main ~ S1.simulate : (SP1.R x w){1} /\ ={x,e} ==> ={res}] =>
    equiv [SP2.RealP(P2).main ~ S2.simulate : (SP2.R x w){1} /\ ={x,e} ==> ={res}] =>
    phoare [Completeness(P(P1,S1,P2,S2)).main : R x w ==> res] = 1%r.
  proof.
    move=> hc1 hc2 hs1 hs2; bypr => &m.
    case: (w{m}) => /= [w1_ hR1 | w2_ hR2].
    + case: (R2_full x{m}.`2) => w2_ hR2.
      have -> : Pr[Completeness(P(P1, S1, P2, S2)).main(x{m}, Left w1_) @ &m : res] =
                Pr[AUX1_L.main(x{m}, w1_, w2_) @ &m : res].
      + byequiv (_: ={x} /\ w{1} = Left w1{2} /\ (SP1.R x.`1 w1 /\ SP2.R x.`2 w2){2} ==> ={res}) => 
          // {hR1 hR2}.
        proc; inline *.
        rcondt{1} ^if; 1: by auto.
        rcondt{1} ^if; 1: by move=> &m1; sp; conseq(:true) => />; auto.
        swap{2} [6..8] 2; auto; call (:true).
        swap{2} 4 3; swap{2} 1 5; wp.
        rnd (fun e => e + e2{2}); wp; call(:true); rnd; call(:true); auto.
        move => &1 &2 /> hR1 hR2 a1 e2 _ [a2 z2].
        split => [ ??| _]; 1: by rewrite add_cancel.
        move=> e _; rewrite funi_ll_full 1:challenges_funi 1:challenges_ll /=. 
        by rewrite add_cancel /= => z1; rewrite /verify /= add_cancel.
      have -> : Pr[AUX1_L.main(x{m}, w1_, w2_) @ &m : res] = 
                Pr[AUX2.main(x{m}, w1_, w2_) @ &m : res].
      + byequiv (_: ={x,w1,w2} /\ (SP1.R x.`1 w1 /\ SP2.R x.`2 w2){2} ==> ={res}) => //.
        by proc; symmetry; wp; call hs2; inline *; auto; do 2! call (:true); auto.
      by apply (prAUX2 &m x{m} w1_ w2_).
    case: (R1_full x{m}.`1) => w1_ hR1.
    have -> : Pr[Completeness(P(P1, S1, P2, S2)).main(x{m}, Right w2_) @ &m : res] =
              Pr[AUX1_R.main(x{m}, w1_, w2_) @ &m : res].
    + byequiv (_: ={x} /\ w{1} = Right w2{2} /\ (SP1.R x.`1 w1 /\ SP2.R x.`2 w2){2} ==> ={res}) => 
          // {hR1 hR2}.
      proc; inline *.
      rcondf{1} ^if; 1: by auto.
      rcondf{1} ^if; 1: by move=> &m1; sp; conseq(:true) => />; auto.
      swap{1} [6..7] -1; swap{1} [7..8] 1.
      do 2! (wp; call (:true)); wp => /=.
      rnd (fun e => e + P.e1{1}); wp => /=.
      call(:true); auto => &1 &2 /> hR1 hR2 e1 _ [a1 z1].
      split => [ ??| _]; 1: by rewrite add_cancel.
      move=> e _; rewrite funi_ll_full 1:challenges_funi 1:challenges_ll /=. 
      by rewrite add_cancel /= => a2 z2; rewrite /verify /= addC add_cancel.
    have -> : Pr[AUX1_R.main(x{m}, w1_, w2_) @ &m : res] = 
              Pr[AUX2.main(x{m}, w1_, w2_) @ &m : res].
    + byequiv (_: ={x,w1,w2} /\ (SP1.R x.`1 w1 /\ SP2.R x.`2 w2){2} ==> ={res}) => //.
      proc; symmetry; wp; sim; call hs1; auto.
    by apply (prAUX2 &m x{m} w1_ w2_).
  qed.

  end section COMPLETENESS.

  section SPECIAL_SOUNDNESS.

  declare module KE1: SP1.KnowledgeExtractor.
  declare module KE2: SP2.KnowledgeExtractor {KE1}.

  local module AUX2 = {
    proc main(x: statement, a: message, e: challenge, z: response, e': challenge, z': response) = {
      var b;
      if (z.`1.`2 <> z'.`1.`2) 
        b <@ SP1.SpecialSoundness(KE1).main(x.`1, a.`1, z.`1.`2, z.`1.`1, z'.`1.`2, z'.`1.`1);
      else
        b <@ SP2.SpecialSoundness(KE2).main(x.`2, a.`2, z.`2.`2, z.`2.`1, z'.`2.`2, z'.`2.`1);
      return b;
    }
  }. 

  lemma SpecialSoundness :
    phoare [SP1.SpecialSoundness(KE1).main: 
      SP1.verify x a e z /\ SP1.verify x a e' z' /\ e <> e' ==> res]= 1%r =>
    phoare [SP2.SpecialSoundness(KE2).main: 
      SP2.verify x a e z /\ SP2.verify x a e' z' /\ e <> e' ==> res]= 1%r =>
    phoare [SpecialSoundness(KE(KE1,KE2)).main: 
      verify x a e z /\ verify x a e' z' /\ e <> e' ==> res]= 1%r.
  proof.
    move=> h1 h2; bypr => &m hR.
    have -> : 
     Pr[SpecialSoundness(KE(KE1, KE2)).main(x{m},a{m},e{m},z{m},e'{m},z'{m}) @ &m : res] =   
     Pr[AUX2.main(x{m},a{m},e{m},z{m},e'{m},z'{m}) @ &m : res].
    byequiv (_: ={arg, glob KE1, glob KE2} ==> ={res}) => //.
    + proc; inline *; sp; if => //; wp; call(:true); auto => />.
    byphoare (: verify x a e z /\ verify x a e' z' /\ e <> e' ==> res) => // {hR}.
    proc; if.
    + call h1; auto => /> &hr.
      case: (z{hr}) => -[z1 e1] [z2 e2] /= [->> [hv1 hv2]].
      by case: (z'{hr}) => -[z1' e1'] [z2' e2'] /= [->> [hv1' hv2']].
    call h2; auto => /> &hr.
    case: (z{hr}) => -[z1 e1] [z2 e2] /= [->> [hv1 hv2]].
    case: (z'{hr}) => -[z1' e1'] [z2' e2'] /= [->> [hv1' hv2']] h ->> /#.
  qed.

  end section SPECIAL_SOUNDNESS.

  section SHVZK.
    declare module P1: SP1.Prover {P}.
    declare module P2: SP2.Prover {P}.

    declare module S1 : SP1.Simulator {P, P2}.
    declare module S2 : SP2.Simulator {P, P1}.

    lemma sHVZK : 
      equiv [SP1.RealP(P1).main ~ S1.simulate : (SP1.R x w) {1} /\ ={x,e} ==> ={res}] =>
      equiv [SP2.RealP(P2).main ~ S2.simulate : (SP2.R x w) {1} /\ ={x,e} ==> ={res}] =>
      equiv [RealP(P(P1,S1,P2,S2)).main ~ S(S1,S2).simulate : (R x w){1} /\ ={x,e} ==> ={res}].
    proof.
      move=> h1 h2; proc; inline * => /=.
      sp; if{1}.
      + rcondt{1} ^if; 1: by move=> *;conseq />.
        swap{1} [6..8] -2; wp; call (:true).
        swap{1} 2 3; conseq />.
        seq 4 2 : ((P.e1, P.e2){1} = (e1, e2){2} /\ x0{1} = x{2} /\ SP1.R x0{1}.`1 w1{1}).
        + by auto => /> &1 &2; case: (w{1}).
        transitivity*{1} { (P.a1, P.z1) <@ SP1.RealP(P1).main(x0.`1, w1, P.e1); } => //; 1: smt().
        + by inline *;auto; do 2! call(:true); auto.
        by call h1.        
      rcondf{1} ^if;  1: by move=> *;conseq />.
      wp; swap{1} 5 3; wp; swap{1} 2 4; swap{1} 3 2.
      seq 5 3 : ((P.e1, P.e2){1} = (e1, e2){2} /\ (P.a1, P.z1){1} = (a1, z1){2} /\
                 x0{1} = x{2} /\ SP2.R x0{1}.`2 w2{1}).  
      + call (:true); wp => /=; rnd (fun e2 => e{2} + e2); auto => /> &1 &2.
        case: (w{1}) => //= w2 hR; split => [ e2 ? | heq ??].
        + by rewrite addC (addC _ e2) add_cancel.
        by rewrite funi_ll_full 1:challenges_funi 1:challenges_ll /= -heq. 
      transitivity*{1} { (P.a2, P.z2) <@ SP2.RealP(P2).main(x0.`2, w2, P.e2); } => //; 1: smt().
      + by inline *;auto; do 2! call(:true); auto.
      by call h2.
    qed.
  
  end section SHVZK.

end OrComp.


