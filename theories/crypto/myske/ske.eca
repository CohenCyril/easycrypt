require import AllCore List DBool SmtMap.

type key.
type plaintext.
type ciphertext.

module type Scheme = {
  proc * init(): unit {}
  proc kg(): key
  proc enc(k:key,p:plaintext): ciphertext 
  proc dec(k:key,c:ciphertext): plaintext option
}.

module type CPA_Oracles = {
  proc lr(p1 p2: plaintext) : ciphertext option
  proc enc(p:plaintext): ciphertext 
}.

module type CCA_Oracles = {
  include CPA_Oracles
  proc dec(c:ciphertext): plaintext option
}.

module type Adv_INDCPA (O:CPA_Oracles) = {
  proc guess(): bool
}.

module type Adv_INDCCA (O:CCA_Oracles) = {
  proc guess(): bool
}.

module WrapS (S:Scheme) : CCA_Oracles = {
  var k   : key
  var b   : bool
  var cs  : ciphertext option
  var log : (ciphertext, plaintext) fmap

  proc init(): unit = {
    S.init();
    k  <- S.kg();
    b  <$ {0,1};
    cs <- None;
    log <- empty;
  }

  proc lr(p1 p2:plaintext) : ciphertext option = {
    var c, r;
    r = None;
    (* We do not answer if the [lr] oracle has been already queried *)
    if (cs = None) {
      c  <@ S.enc(k, if b then p1 else p2);
      cs <- Some c;
      r  <- cs;
    }
    return r;
  } 

  proc enc(p:plaintext): ciphertext = {
    var c:ciphertext;
    c = S.enc(k,p);
    log.[c] <- p;
    return c;
  }

  proc dec(c:ciphertext): plaintext option = {
    var r = None;
    (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
       [enc] *)
    if (cs <> Some c) {
    (* If it is an answer to the encryption oracle we return the msg directly *)
      if (c \in log) r <- log.[c]; 
      else r <@ S.dec(k,c); 
    }
    return r;
  }
}.

module INDCPA (S:Scheme, A:Adv_INDCPA) = {
  module O = WrapS(S)

  proc main(): bool = {
    var b';
    O.init();
    b' <@ A(O).guess();
    return (WrapS.b = b');
  }
}.

module INDCCA (S:Scheme, A:Adv_INDCCA) = {
  module O = WrapS(S)

  proc main(): bool = {
    var b';
    O.init();
    b' <@ A(O).guess();
    return (WrapS.b = b');
  }
}.

module type UFCMA_Oracles = {
  proc sign (_:plaintext) : ciphertext
  proc submit (_:ciphertext) : unit 
}.

module type Adv_UFCMA (O:UFCMA_Oracles) = {
  proc forge () : unit
}.
 
module WrapUF(S:Scheme) = {
  var k:key
  var lc: ciphertext list
  var forged: bool

  proc init () = {
    S.init();
    k  <- S.kg();
    forged <- false;
    lc <- [];
  }
    
  proc sign (m:plaintext) : ciphertext = {
    var c;
    c <@ S.enc(k, m);
    lc <- c :: lc;
    return c;
  }

  proc submit(c:ciphertext) : unit = {
    var d;
    d <@ S.dec(k,c);
    forged <- forged || (d <> None && !(c \in lc));
  }
}.
  
module UFCMA(S:Scheme, A:Adv_UFCMA) = {
  module O = WrapUF(S)
  proc main () = {
    O.init();
    A(O).forge();
    return WrapUF.forged;
  }
}.

(* *************************************************************** *)
(* We prove that CCA <= CPA + CMA                                  *)

module Adv_INDCPA (A:Adv_INDCCA, O:CPA_Oracles) = {

  var m : (ciphertext, plaintext) fmap
  var cs : ciphertext option

  module OCCA = {
    proc enc(p:plaintext) : ciphertext = {
      var c;
      c <@ O.enc(p);
      m.[c] <- p;
      return c;
    }
    
    proc lr(p1 p2:plaintext) = {
      var r = None;
      if (cs = None) {
        cs  <@ O.lr(p1, p2);
        r <- cs;
      }
      return r;
    }

    proc dec(c:ciphertext) = {
      var r = None;
      if (cs <> Some c) r <- m.[c];
      return r;
    }  
  }
  
  proc guess() : bool = {
    var b;
    m  <- empty;
    cs <- None;
    b <@ A(OCCA).guess();
    return b;
  }
}.

module Adv_UFCMA(A:Adv_INDCCA, O:UFCMA_Oracles) = {

  module OCCA = {
    proc lr(p1 p2:plaintext) : ciphertext option = {
      var c, r;
      r = None;
      (* We do not answer if the [lr] oracle has been already queried *)
      if (WrapS.cs = None) {
        c  <@ O.sign(if WrapS.b then p1 else p2);
        WrapS.cs <- Some c;
        r  <- WrapS.cs;
      }
      return r;
    } 
  
    proc enc(p:plaintext): ciphertext = {
      var c:ciphertext;
      c = O.sign(p);
      WrapS.log.[c] <- p;
      return c;
    }
  
    proc dec(c:ciphertext): plaintext option = {
      var r = None;
      (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
        [enc] *)
      if (WrapS.cs <> Some c) {
      (* If it is an answer to the encryption oracle we return the msg directly *)
        if (c \in WrapS.log) r <- WrapS.log.[c]; 
        else O.submit(c); 
      }
      return r;
    }
  }

  proc forge () = {
    var b';
    WrapS.b  <$ {0,1};
    WrapS.cs <- None;
    WrapS.log <- empty;
    b' <@ A(OCCA).guess();
  }

}.

module E2 (S : Scheme) = {
  proc enc_dec (k : key, p1: plaintext, c2 : ciphertext) : ciphertext * plaintext option = {
    var c1, p2;
    c1 <@ S.enc(k,p1);
    p2 <@ S.dec(k,c2);
    return (c1,p2);
  }
  proc dec_enc (k : key, p1: plaintext, c2 : ciphertext) : ciphertext * plaintext option = {
    var c1, p2;
    p2 <@ S.dec(k,c2);
    c1 <@ S.enc(k,p1);
    return (c1,p2);
  }
}.

section PROOFS.

  declare module S:Scheme{ WrapS, WrapUF, Adv_INDCPA}.
  declare module A:Adv_INDCCA {S,WrapS, WrapUF, Adv_INDCPA}.


  axiom enc_ll : islossless S.enc.
  axiom dec_ll : islossless S.dec.
  axiom A_ll   : 
    forall (O <: CCA_Oracles{A}), 
      islossless O.lr => islossless O.enc => islossless O.dec => islossless A(O).guess.

  local module WrapS1 : CCA_Oracles = {
    var bad : bool
    var lc  : ciphertext list

    proc init(): unit = {
      S.init();
      WrapS.k  <- S.kg();
      WrapS.b  <$ {0,1};
      WrapS.cs <- None;
      WrapS.log <- empty;
      bad <- false;
      lc <- [];
    }
  
    proc lr(p1 p2:plaintext) : ciphertext option = {
      var c, r;
      r = None;
      (* We do not answer if the [lr] oracle has been already queried *)
      if (WrapS.cs = None) {
        c <- witness;
        c <@ S.enc(WrapS.k, if WrapS.b then p1 else p2);
        WrapS.cs <- Some c;
        r  <- WrapS.cs;
      }
      return r;
    } 
  
    proc enc(p:plaintext): ciphertext = {
      var c:ciphertext;
      c <- witness;
      c = S.enc(WrapS.k,p);
      WrapS.log.[c] <- p;
      return c;
    }
  
    proc dec(c:ciphertext): plaintext option = {
      var r = None;
      (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
         [enc] *)
      if (WrapS.cs <> Some c) {
      (* If it is an answer to the encryption oracle we return the msg directly *)
        if (c \in WrapS.log) r <- WrapS.log.[c]; 
        else {
          lc <- rcons lc c;
          r <@ S.dec(WrapS.k,c); 
          bad <- bad || r <> None;
          r <- None;
        }
      }
      return r;
    }

    proc all_decs () = {
      var i, p, c;
      i = 0;
      p <- witness;
      c <- witness;
      while (i < size lc) {
        c <- nth witness lc i;
        p <@ S.dec(WrapS.k, c);
        i <- i + 1;
      }
    }

  }.

  local module AUX = {
    proc main(): bool = {
      var b';
      WrapS1.init();
      b' <@ A(WrapS1).guess();
      return (WrapS.b = b');
    }
  }.
  
  local equiv CCA_AUX : INDCCA(S,A).main ~ AUX.main : ={glob A, glob S} ==> (!WrapS1.bad{2} => ={res}).
  proof.
    proc;inline *; wp.
    call (_: WrapS1.bad, ={glob S, glob WrapS}).
    + by apply A_ll.
    + by proc;inline *; sp; if => //;wp;call(_:true); auto.
    + by move=> &2 _; islossless; apply enc_ll.
    + move=> _; conseq />; islossless; apply enc_ll.
    + by proc;inline *; sim />.
    + by move=> &2 _; islossless; apply enc_ll.
    + by move=> &2; conseq />; islossless; apply enc_ll.
    + proc; sp 1 1; if => //. 
      if; 1,2: by auto.
      by auto; call(_:true); auto => />.
    + by move=> &2 _; islossless; apply dec_ll.
    + by move=> &2;proc; sp; if => //; if => //; auto; call dec_ll; auto => />.
    by auto; do 2! call(_:true); auto => /> /#.
  qed.

  local equiv AUX_UFCMA : AUX.main ~ UFCMA(S, Adv_UFCMA(A)).main : ={glob A, glob S} ==> WrapS1.bad{1} = res{2}.
  proof.
    proc; inline *; wp.
    call (_:  WrapS1.bad{1} = WrapUF.forged{2} /\ 
              ={glob S, WrapS.b, WrapS.cs, WrapS.log} /\ WrapS.k{1} = WrapUF.k{2} /\
              (forall c, c \in WrapUF.lc => (c \in  WrapS.log \/ WrapS.cs = Some c)){2}).
    + proc; inline *; sp 1 1; if => //.
      by auto; call (_:true); auto => /> /#. 
    + by proc; inline *; wp; call (_:true); auto => />; smt (mem_set).
    + proc; inline *; sp; if => //; if => //; auto.
      by call (_:true); auto => /> /#.
    by auto; do 2! call (_: true); auto.
  qed.

  local module WrapS2 = {
    include WrapS1 [-dec, init]
    proc init () : unit = {
      S.init();
      WrapS.k  <- S.kg();
      WrapS.b  <$ {0,1};
      WrapS.cs <- None;
      WrapS.log <- empty;
      WrapS1.lc <- [];
      WrapS1.all_decs();
    }
      
    proc dec(c:ciphertext): plaintext option = {
      var r = None;
      (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
         [enc] *)
      if (WrapS.cs <> Some c) {
      (* If it is an answer to the encryption oracle we return the msg directly *)
        if (c \in WrapS.log) r <- WrapS.log.[c]; 
        else {
          WrapS1.lc <- rcons WrapS1.lc c;
          r <@ S.dec(WrapS.k,c); 
          r <- None;
        }
      }
      return r;
    }
  }.

  local module WrapS3 = {
    include WrapS1 [-dec, init]
    proc init () : unit = {
      S.init();
      WrapS.k  <- S.kg();
      WrapS.b  <$ {0,1};
      WrapS.cs <- None;
      WrapS.log <- empty;
      WrapS1.lc <- [];
    }
      
    proc dec(c:ciphertext): plaintext option = {
      var r = None;
      (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
         [enc] *)
      if (WrapS.cs <> Some c) {
      (* If it is an answer to the encryption oracle we return the msg directly *)
        if (c \in WrapS.log) r <- WrapS.log.[c]; 
        else {
          WrapS1.lc <- rcons WrapS1.lc c;
        }
      }
      return r;
    }
  }.
 
  axiom enc_dec : equiv [ E2(S).enc_dec ~ E2(S).dec_enc : ={arg, glob S} ==> ={res, glob S}].

  local equiv AUX_CPA : AUX.main ~INDCPA(S, Adv_INDCPA(A)).main : ={glob A, glob S} ==> ={res}.
  proof.
    proc.
    transitivity* {1} { WrapS2.init();
                        b' <@ A(WrapS2).guess(); } => />; 1: by smt().
    + inline *; sim.
      by rcondf{2} ^while; auto; do 2!call (_:true).
    transitivity*{1} { WrapS3.init();
                       b' <@ A(WrapS3).guess(); 
                       WrapS1.all_decs();
                      } => />; 1: smt(); last first.
    + inline{1} WrapS1.all_decs.
      while{1} true (size WrapS1.lc - i){1}.
      + by move=> _ z; wp; call dec_ll; auto; smt(head_behead).
      wp; conseq (_: ={b', WrapS.b}); 1: smt(size_eq0 size_ge0).
      inline *; wp.
      call (_:  ={glob S, glob WrapS} /\ 
                 Adv_INDCPA.m{2} = WrapS.log{1} /\
                 Adv_INDCPA.cs{2} = WrapS.cs{1}).
      + proc; inline *; sp; if => //.
        by rcondt{2} 4; auto; call (_: true); auto.
      + by proc; inline *; auto; call (_: true); auto.
      + by proc; inline *; auto => /> ??; rewrite domNE => ->. 
      by auto; do 2!call (_:true); auto.
    (* Eager stuff *)
    inline WrapS2.init WrapS3.init.  
    seq 6 6 : ( ={glob S, glob A, glob WrapS, WrapS1.lc} ).
    + by auto; do 2! call (_:true).
    eager call (: ={glob A, glob S, glob WrapS, WrapS1.lc} ==> 
                   ={res, glob A, glob S, glob WrapS, WrapS1.lc}) => //.
    eager proc (H : WrapS1.all_decs(); ~ WrapS1.all_decs(); :
       ={glob S, glob WrapS, WrapS1.lc}
       ==> ={glob S,glob WrapS, WrapS1.lc})
       (={glob S, glob WrapS, WrapS1.lc});auto => //; 1,3,5,7 : by sim.

    + eager proc.
      swap{1} 2 -1; sp 1 1.
      swap{2} 2 1; wp.
      eager if => //; last by sim.
      + by move=> &m2 b1; conseq />.
      swap{1} 1 1; sp 1 1.
      swap{2} -2; wp; inline WrapS1.all_decs.
      swap{2} 3; sp 3 3.
      conseq (_: ={glob S, glob WrapS, WrapS1.lc, p1, p2, c, i, c0, p} ==> ={glob S, c}) => />.
      symmetry.
      eager while (H1: c <@ S.enc(WrapS.k, if WrapS.b then p1 else p2); ~
                       c <@ S.enc(WrapS.k, if WrapS.b then p1 else p2); : 
                       ={glob S, glob WrapS, WrapS1.lc, p1, p2, c, i, c0, p} ==>
                       ={glob S, glob WrapS, WrapS1.lc, p1, p2, c, i, c0, p}) => //; 1,3: by sim.
      swap{1} 1; seq 1 1 : (#pre); 1: by auto.
      swap{2} 2 1; wp; conseq />.
      transitivity*{1} { (c,p) <@ E2(S).enc_dec(WrapS.k, if WrapS.b then p1 else p2, c0); } => //; 1: smt().
      + by inline *; auto; do 2! call (_: true); auto.
      transitivity*{2} { (c,p) <@ E2(S).dec_enc(WrapS.k, if WrapS.b then p1 else p2, c0); } => //; 1: smt().
      + by call enc_dec.
      by inline *; auto; do 2! call (_: true); auto.

    + eager proc.
      swap{1} 1; sp 1 1.
      swap{2} -2; wp; inline WrapS1.all_decs.
      swap{2} 3; sp 3 3.
      conseq (_: ={glob S, glob WrapS, WrapS1.lc, p0, c, i, c0, p} ==> ={glob S, c}) => />.
      symmetry.
      eager while (H1: c <@ S.enc(WrapS.k, p); ~
                       c <@ S.enc(WrapS.k, p); : 
                       ={glob S, glob WrapS, WrapS1.lc, p0, c, i, c0, p} ==>
                       ={glob S, glob WrapS, WrapS1.lc, p0, c, i, c0, p}) => //; 1,3: by sim.
      swap{1} 1; seq 1 1 : (#pre); 1: by auto.
      swap{2} 2 1; wp; conseq />.
      transitivity*{1} { (c,p0) <@ E2(S).enc_dec(WrapS.k, p, c0); } => //; 1: smt().
      + by inline *; auto; do 2! call (_: true); auto.
      transitivity*{2} { (c,p0) <@ E2(S).dec_enc(WrapS.k, p, c0); } => //; 1: smt().
      + by call enc_dec.
      by inline *; auto; do 2! call (_: true); auto.

    eager proc.      
    swap{1} 2 -1; sp 1 1.
    swap{2} -1; wp.
    eager if => //; 1: by move=> &m2 b1; conseq />.
    + eager if => //; 1: by move=> &m2 b1; conseq />.
      + by swap{1} 1;sim.
      swap{1} 2 1; wp; inline WrapS1.all_decs.
      conseq (: ={glob S} /\ rcons WrapS1.lc{1} c{1} = WrapS1.lc{2}); 1: by progress.
      splitwhile{2} 5 : (i < size WrapS1.lc - 1).
      seq 4 5 : (={glob S, WrapS.k, i} /\ rcons WrapS1.lc{1} c{1} = WrapS1.lc{2} /\ (i = size WrapS1.lc){1}).
      + while (={glob S, WrapS.k, i} /\ rcons WrapS1.lc{1} c{1} = WrapS1.lc{2} /\ (0 <= i <= size WrapS1.lc){1}).
        + by wp; call (_:true); auto => />; smt (size_rcons nth_rcons).
        by auto => />; smt (size_rcons size_ge0).
      rcondt{2} ^while.   
      + move=> &m; auto => />; smt(size_rcons).
      rcondf{2} ^while.
      + move=> &m;auto; conseq (:true) => // />; smt (size_rcons).
      wp; call (_:true); auto => />; smt (nth_rcons).
    by sim. 
  qed.

  lemma CCA_from_CPA_UFCMA &m : 
    Pr[INDCCA(S,A).main() @ &m : res] <=
    Pr[INDCPA(S,Adv_INDCPA(A)).main() @ &m : res] +
    Pr[UFCMA(S,Adv_UFCMA(A)).main() @ &m : res].
  proof.
    have : Pr[INDCCA(S,A).main() @ &m : res] <=
           Pr[AUX.main() @ &m : res] + Pr[AUX.main() @ &m : WrapS1.bad].
    + by byequiv CCA_AUX => /> /#.
    have -> : Pr[AUX.main() @ &m : WrapS1.bad] = Pr[UFCMA(S, Adv_UFCMA(A)).main() @ &m : res].
    + by byequiv AUX_UFCMA.
    have -> //: Pr[AUX.main() @ &m : res] = Pr[INDCPA(S, Adv_INDCPA(A)).main() @ &m : res].
    by byequiv AUX_CPA.
  qed.

end section PROOFS.

print CCA_from_CPA_UFCMA.