require import AllCore List DBool SmtMap.

type key.
type plaintext.
type ciphertext.

module type Scheme = {
  proc * init(): unit {}
  proc kg(): key
  proc enc(k:key,p:plaintext): ciphertext 
  proc dec(k:key,c:ciphertext): plaintext option
}.

module type CPA_Oracles = {
  proc lr(p1 p2: plaintext) : ciphertext option
  proc enc(p:plaintext): ciphertext 
}.

module type CCA_Oracles = {
  include CPA_Oracles
  proc dec(c:ciphertext): plaintext option
}.

module type Adv_INDCPA (O:CPA_Oracles) = {
  proc guess(): bool
}.

module type Adv_INDCCA (O:CCA_Oracles) = {
  proc guess(): bool
}.

module WrapS (S:Scheme) : CCA_Oracles = {
  var k:key
  var b:bool
  var cs : ciphertext option

  proc init(): unit = {
    S.init();
    k  <- S.kg();
    b  <$ {0,1};
    cs <- None;
  }

  proc lr(p1 p2:plaintext) : ciphertext option = {
    var c, r;
    r = None;
    (* We do not answer if the [lr] oracle has been already queried *)
    if (cs = None) {
      c  <@ S.enc(k, if b then p1 else p2);
      cs <- Some c;
      r  <- cs;
    }
    return r;
  } 

  proc enc(p:plaintext): ciphertext = {
    var r:ciphertext;

    r = S.enc(k,p);
    return r;
  }

  proc dec(c:ciphertext): plaintext option = {
    var r = None;
    (* We do not answer if [c] correspond to the challenge [cs] *)
    if (cs <> Some c) r <@ S.dec(k,c);
    return r;
  }

}.

module INDCPA (S:Scheme, A:Adv_INDCPA) = {
  module O = WrapS(S)

  proc main(): bool = {
    var b';
    O.init();
    b' <@ A(O).guess();
    return (WrapS.b = b');
  }
}.

module INDCCA (S:Scheme, A:Adv_INDCCA) = {
  module O = WrapS(S)

  proc main(): bool = {
    var b';
    O.init();
    b' <@ A(O).guess();
    return (WrapS.b = b');
  }
}.

module type CMA_Oracles = {
  proc sign (_:plaintext) : ciphertext
  proc submit (_:ciphertext) : plaintext option
}.

module type Adv_CMA (O:CMA_Oracles) = {
  proc forge () : unit
}.
 
module WrapF(S:Scheme) = {
  var k:key
  var lc: ciphertext list
  var forged: bool

  proc init () = {
    S.init();
    k  <- S.kg();
    forged <- false;
    lc <- [];
  }
    
  proc sign (m:plaintext) : ciphertext = {
    var c;
    c <@ S.enc(k, m);
    lc <- c :: lc;
    return c;
  }

  proc submit(c:ciphertext) : plaintext option = {
    var d;
    d <@ S.dec(k,c);
    forged <- forged || (d <> None && !(c \in lc));
    return d;
  }
}.
  
module INDCMA(S:Scheme, A:Adv_CMA) = {
  module O = WrapF(S)
  proc main () = {
    O.init();
    A(O).forge();
    return WrapF.forged;
  }
}.

(* *************************************************************** *)
(* We prove that CCA <= CPA + CMA                                  *)

module Adv_INDCPA (A:Adv_INDCCA, O:CPA_Oracles) = {
  var m: (ciphertext, plaintext) fmap

  module OCCA = {
    proc enc(p:plaintext) : ciphertext = {
      var c;
      c <@ O.enc(p);
      m.[c] <- p;
      return c;
    }
    
    proc lr =  O.lr

    proc dec(c:ciphertext) = {
      return m.[c];
    }  
  }
  
  proc guess() : bool = {
    var b;
    m <- empty;
    b <@ A(OCCA).guess();
    return b;
  }
}.

module Adv_INDCMA(A:Adv_INDCCA, O:CMA_Oracles) = {
  module OCCA = {
    proc lr(p1 p2:plaintext) : ciphertext option = {
      var c, r;
      r = None;
      (* We do not answer if the [lr] oracle has been already queried *)
      if (WrapS.cs = None) {
        c  <@ O.sign(if WrapS.b then p1 else p2);
        WrapS.cs <- Some c;
        r  <- WrapS.cs;
      }
      return r;
    } 
  
    proc enc(p:plaintext): ciphertext = {
      var r:ciphertext;
  
      r = O.sign(p);
      return r;
    }
  
    proc dec(c:ciphertext): plaintext option = {
      var r:plaintext option;
      (* We do not answer if [c] correspond to the challenge [cs] *)
      if (WrapS.cs <> Some c) r <@ O.submit(c);
      return r;
    }
  }

  proc forge () = {
    var b';
    WrapS.b  <$ {0,1};
    WrapS.cs <- None;
    b' <@ A(OCCA).guess();
  }

}.

section PROOFS.

  declare module S:Scheme{ WrapS, WrapF, Adv_INDCPA}.
  declare module A:Adv_INDCCA {S,WrapS, WrapF,  Adv_INDCPA}.

  local module WrapS1 (S:Scheme) : CCA_Oracles = {
    var k:key
    var b:bool
    var cs : ciphertext option
    var bad : bool
  
    proc init(): unit = {
      S.init();
      k  <- S.kg();
      b  <$ {0,1};
      Adv_INDCPA.m <- empty;
      b  <- false;
      cs <- None;
    }
  
    proc lr(p1 p2:plaintext) : ciphertext option = {
      var c, r;
      r = None;
      (* We do not answer if the [lr] oracle has been already queried *)
      if (cs = None) {
        c  <@ S.enc(k, if b then p1 else p2);
        cs <- Some c;
        r  <- cs;
      }
      return r;
    } 
  
    proc enc(p:plaintext): ciphertext = {
      var r:ciphertext;
      r = S.enc(k,p);
      Adv_INDCPA.m.[r] <- p;
      return r;
    }
  
    proc dec(c:ciphertext): plaintext option = {
      var r = None;
      (* We do not answer if [c] correspond to the challenge [cs] *)
      if (cs <> Some c) {
        if (c \in Adv_INDCPA.m) { 
          r <- Adv_INDCPA.m.[c]; 
        } else {
          r <@ S.dec(k,c);
          bad <- bad || r <> None;
        }
      }
      return r;
    }
  
  }.
bla
  local module AUX = {
    module OCCA = {
       proc enc(p:plaintext) : ciphertext = {
        var c;
        c <@ O.enc(p);
        Adv_INDCPA.[c] <- p;
        return c;
      }
    
      proc lr =  O.lr

      proc dec(c:ciphertext) = {
        if (cs <> Some c) r <@ S.dec(k,c);
        return m.[c];
    }  
  }
  
  proc guess() : bool = {
    var b;
    m <- empty;
    b <@ A(OCCA).guess();
    return b;
  }
}.
    
  }

      


