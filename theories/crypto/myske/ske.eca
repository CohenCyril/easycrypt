require import AllCore List DBool SmtMap.

type key.
type plaintext.
type ciphertext.

module type Scheme = {
  proc * init(): unit {}
  proc kg(): key
  proc enc(k:key,p:plaintext): ciphertext 
  proc dec(k:key,c:ciphertext): plaintext option
}.

module type CPA_Oracles = {
  proc lr(p1 p2: plaintext) : ciphertext option
  proc enc(p:plaintext): ciphertext 
}.

module type CCA_Oracles = {
  include CPA_Oracles
  proc dec(c:ciphertext): plaintext option
}.

module type Adv_INDCPA (O:CPA_Oracles) = {
  proc guess(): bool
}.

module type Adv_INDCCA (O:CCA_Oracles) = {
  proc guess(): bool
}.

module WrapS (S:Scheme) : CCA_Oracles = {
  var k   : key
  var b   : bool
  var cs  : ciphertext option
  var log : (ciphertext, plaintext) fmap

  proc init(): unit = {
    S.init();
    k  <- S.kg();
    b  <$ {0,1};
    cs <- None;
    log <- empty;
  }

  proc lr(p1 p2:plaintext) : ciphertext option = {
    var c, r;
    r = None;
    (* We do not answer if the [lr] oracle has been already queried *)
    if (cs = None) {
      c  <@ S.enc(k, if b then p1 else p2);
      cs <- Some c;
      r  <- cs;
    }
    return r;
  } 

  proc enc(p:plaintext): ciphertext = {
    var c:ciphertext;
    c = S.enc(k,p);
    log.[c] <- p;
    return c;
  }

  proc dec(c:ciphertext): plaintext option = {
    var r = None;
    (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
       [enc] *)
    if (cs <> Some c) {
    (* If it is an answer to the encryption oracle we return the msg directly *)
      if (c \in log) r <- log.[c]; 
      else r <@ S.dec(k,c); 
    }
    return r;
  }
}.

module INDCPA (S:Scheme, A:Adv_INDCPA) = {
  module O = WrapS(S)

  proc main(): bool = {
    var b';
    O.init();
    b' <@ A(O).guess();
    return (WrapS.b = b');
  }
}.

module INDCCA (S:Scheme, A:Adv_INDCCA) = {
  module O = WrapS(S)

  proc main(): bool = {
    var b';
    O.init();
    b' <@ A(O).guess();
    return (WrapS.b = b');
  }
}.

module type CMA_Oracles = {
  proc sign (_:plaintext) : ciphertext
  proc submit (_:ciphertext) : plaintext option
}.

module type Adv_CMA (O:CMA_Oracles) = {
  proc forge () : unit
}.
 
module WrapF(S:Scheme) = {
  var k:key
  var lc: ciphertext list
  var forged: bool

  proc init () = {
    S.init();
    k  <- S.kg();
    forged <- false;
    lc <- [];
  }
    
  proc sign (m:plaintext) : ciphertext = {
    var c;
    c <@ S.enc(k, m);
    lc <- c :: lc;
    return c;
  }

  proc submit(c:ciphertext) : plaintext option = {
    var d;
    d <@ S.dec(k,c);
    forged <- forged || (d <> None && !(c \in lc));
    return d;
  }
}.
  
module INDCMA(S:Scheme, A:Adv_CMA) = {
  module O = WrapF(S)
  proc main () = {
    O.init();
    A(O).forge();
    return WrapF.forged;
  }
}.

(* *************************************************************** *)
(* We prove that CCA <= CPA + CMA                                  *)

module Adv_INDCPA (A:Adv_INDCCA, O:CPA_Oracles) = {

  var m : (ciphertext, plaintext) fmap
  var cs : ciphertext option

  module OCCA = {
    proc enc(p:plaintext) : ciphertext = {
      var c;
      c <@ O.enc(p);
      m.[c] <- p;
      return c;
    }
    
    proc lr(p1 p2:plaintext) = {
      var r = None;
      if (cs = None) {
        cs  <@ O.lr(p1, p2);
        r <- cs;
      }
      return r;
    }

    proc dec(c:ciphertext) = {
      var r = None;
      if (cs <> Some c) r <- m.[c];
      return r;
    }  
  }
  
  proc guess() : bool = {
    var b;
    m  <- empty;
    cs <- None;
    b <@ A(OCCA).guess();
    return b;
  }
}.

module Adv_INDCMA(A:Adv_INDCCA, O:CMA_Oracles) = {

  module OCCA = {
    proc lr(p1 p2:plaintext) : ciphertext option = {
      var c, r;
      r = None;
      (* We do not answer if the [lr] oracle has been already queried *)
      if (WrapS.cs = None) {
        c  <@ O.sign(if WrapS.b then p1 else p2);
        WrapS.cs <- Some c;
        r  <- WrapS.cs;
      }
      return r;
    } 
  
    proc enc(p:plaintext): ciphertext = {
      var c:ciphertext;
      c = O.sign(p);
      WrapS.log.[c] <- p;
      return c;
    }
  
    proc dec(c:ciphertext): plaintext option = {
      var r = None;
      (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
        [enc] *)
      if (WrapS.cs <> Some c) {
      (* If it is an answer to the encryption oracle we return the msg directly *)
        if (c \in WrapS.log) r <- WrapS.log.[c]; 
        else r <@ O.submit(c); 
      }
      return r;
    }
  }

  proc forge () = {
    var b';
    WrapS.b  <$ {0,1};
    WrapS.cs <- None;
    WrapS.log <- empty;
    b' <@ A(OCCA).guess();
  }

}.

section PROOFS.

  declare module S:Scheme{ WrapS, WrapF, Adv_INDCPA}.
  declare module A:Adv_INDCCA {S,WrapS, WrapF,  Adv_INDCPA}.


  axiom enc_ll : islossless S.enc.
  axiom dec_ll : islossless S.dec.
  axiom A_ll   : 
    forall (O <: CCA_Oracles{A}), 
      islossless O.lr => islossless O.enc => islossless O.dec => islossless A(O).guess.


  local module WrapS1 (S:Scheme) : CCA_Oracles = {
    var bad : bool

    proc init(): unit = {
      S.init();
      WrapS.k  <- S.kg();
      WrapS.b  <$ {0,1};
      WrapS.cs <- None;
      WrapS.log <- empty;
      bad <- true;
    }
  
    proc lr(p1 p2:plaintext) : ciphertext option = {
      var c, r;
      r = None;
      (* We do not answer if the [lr] oracle has been already queried *)
      if (WrapS.cs = None) {
        c  <@ S.enc(WrapS.k, if WrapS.b then p1 else p2);
        WrapS.cs <- Some c;
        r  <- WrapS.cs;
      }
      return r;
    } 
  
    proc enc(p:plaintext): ciphertext = {
      var c:ciphertext;
      c = S.enc(WrapS.k,p);
      WrapS.log.[c] <- p;
      return c;
    }
  
    proc dec(c:ciphertext): plaintext option = {
      var r = None;
      (* We do not answer if [c] correspond to the challenge [cs] or if the cipher has been generated by 
         [enc] *)
      if (WrapS.cs <> Some c) {
      (* If it is an answer to the encryption oracle we return the msg directly *)
        if (c \in WrapS.log) r <- WrapS.log.[c]; 
        else {
          r <@ S.dec(WrapS.k,c); 
          bad <- bad || r <> None;
        }
      }
      return r;
    }
  }.

  local module AUX = {
    proc main(): bool = {
      var b';
      WrapS1(S).init();
      b' <@ A(WrapS1(S)).guess();
      return (WrapS.b = b');
    }
  }.

  local equiv CCA_AUX : INDCCA(S,A).main ~ AUX.main : ={glob A} ==> ={res}.
  proof. by proc; sim. qed.

  local lemma lr_ll  : islossless WrapS1(S).lr.
  proof. by islossless; apply enc_ll. qed.

  local equiv CPA_AUX : INDCPA(S,Adv_INDCPA(A)).main ~ AUX.main : ={glob A} ==> (!WrapS1.bad{2} => ={res}).
  proof.
    proc;inline *; wp.  
    call (_: WrapS1.bad, ={glob S, WrapS.k, WrapS.cs, WrapS.b} /\ 
             Adv_INDCPA.m{1} = WrapS.log{2} /\
             Adv_INDCPA.cs{1} = WrapS.cs{2}).
    + by apply A_ll.
    + proc;inline *; sp; if => //.
      by rcondt{1} 4; auto; call (_: true); auto.
    + by move=> &2 _; islossless; apply enc_ll.
    + move=> _; conseq />; islossless; apply enc_ll.
    + by proc;inline *; sim />.
    + by move=> &2 _; islossless; apply enc_ll.
    + by move=> &2; conseq />; islossless; apply enc_ll.
    + proc; sp 1 1; if => //.
      if{2}; auto.           
      call{2} dec_ll; auto.
sim />.  